#nullable enable
using UnityEngine;
using Newtonsoft.Json;
using System.IO;
using System.Text;
using System.Collections.Generic;
using System.Threading.Tasks;
using ShowGenerator; // For ShowGeneratorApiKeys, ShowConfig, ShowEpisode, ClaudeMessage, ClaudeApiRequestPayload, ClaudeApiResponse
using ShowRunner; // For EpisodeCompletionData (if EventManager uses this exact struct)
using UnityEngine.Networking; // For fetching AI News JSON
using System; // For DateTime
using System.Text.RegularExpressions; // For sanitizing names
using System.Linq; // For Linq operations

// Define ShowRunner.EpisodeCompletionData if it's not globally accessible
// This is often defined within ShowRunner.cs, ensure the namespace matches.
// For now, assuming it's accessible via ShowRunner.EpisodeCompletionData or a similar using directive.

// Structure for the output metadata JSON
[System.Serializable]
public class EpisodeMetadata
{
    public string? video_file;
    public string? title;
    public string? description;
    public string? tags;
    public string? category_id;
    public string? privacy_status;
    public string? thumbnail_file;
    public string? duration; // Placeholder, e.g., "00:00"
    public string? generated_at; // ISO 8601 format
}

[System.Serializable]
public class EpisodeMetadataContainer
{
    public EpisodeMetadata? episode_metadata;
}

// Structure to parse the main show JSON file (e.g., AI_Podcast_S1E57.json)
[System.Serializable]
public class FullShowDataFormat
{
    public ShowGenerator.ShowConfig? config;
    public List<ShowGenerator.ShowEpisode>? episodes;
}

// Placeholder for LLM response structure
[System.Serializable]
internal class LLMMetadataResponse
{
    public string? title;
    public string? description;
    public string? tags;
}

public class YouTubeMetadataGenerator : MonoBehaviour
{
    [Header("API Configuration")]
    [Tooltip("Assign your ShowGeneratorApiKeys ScriptableObject here.")]
    public ShowGeneratorApiKeys? apiKeysConfig;
    [Tooltip("If true, uses the wrapper URL from ApiKeysConfig. If false, uses direct Anthropic API calls.")]
    public bool useWrapperEndpoint = true;

    [Header("Metadata Settings")]
    [Tooltip("Default YouTube category ID. '22' is People & Blogs.")]
    public string defaultCategoryId = "22";
    [Tooltip("Default privacy status for the video.")]
    public YoutubeUploader.PrivacyStatus defaultPrivacyStatus = YoutubeUploader.PrivacyStatus.Private;

    [Header("Connections")]
    [Tooltip("Assign the YoutubeUploader component here if you want to prepare upload details.")]
    public YoutubeUploader? youtubeUploader;
    [Tooltip("Assign the YouTubeTranscriptGenerator component here to populate the language dropdown.")]
    public YouTubeTranscriptGenerator? transcriptGeneratorReference;
    [Tooltip("If checked, the system will attempt to automatically upload the video to YouTube after metadata generation.")]
    public bool enableAutomaticUpload = false; // Default to false

    [Header("Upload Settings")]
    [Tooltip("Specify language for upload. Use 'Original', a language code (e.g., 'ch', 'ko'), or leave empty/type 'None' to prevent any auto-upload triggered by this script.")]
    public string uploadLanguagePreference = "Original"; // Default to uploading the original version

    [Header("Debugging")]
    [Tooltip("The last LLM prompt generated by this script for the original language.")]
    [TextArea(5, 15)]
    public string? lastGeneratedOriginalLLMPrompt;
    [Tooltip("The last LLM prompt generated by this script for a translated language.")]
    [TextArea(5, 15)]
    public string? lastGeneratedTranslatedLLMPrompt;

    private const string AiNewsJsonUrl = "https://elizaos.github.io/knowledge/ai-news/elizaos/json/daily.json";
    private const string DirectClaudeApiUrl = "https://api.anthropic.com/v1/messages";
    private const string ClaudeApiVersion = "2023-06-01";

    private void OnEnable()
    {
        EventManager.OnOriginalTranscriptGenerated += HandleOriginalTranscriptReady;
        EventManager.OnTranslatedTranscriptGenerated += HandleTranslatedTranscriptReady; // New subscription
        Debug.Log("[YouTubeMetadataGenerator] Subscribed to OnOriginalTranscriptGenerated and OnTranslatedTranscriptGenerated.");
    }

    private void OnDisable()
    {
        EventManager.OnOriginalTranscriptGenerated -= HandleOriginalTranscriptReady;
        EventManager.OnTranslatedTranscriptGenerated -= HandleTranslatedTranscriptReady; // New unsubscription
        Debug.Log("[YouTubeMetadataGenerator] Unsubscribed from OnOriginalTranscriptGenerated and OnTranslatedTranscriptGenerated.");
    }

    private async void HandleOriginalTranscriptReady(OriginalTranscriptData data) 
    {
        Debug.Log($"[YouTubeMetadataGenerator] Received OnOriginalTranscriptReady: EpisodeId: {data.EpisodeId}, TranscriptPath: {data.OriginalTranscriptFilePath}, JsonPath: {data.EpisodeJsonFilePath}");
        await ProcessAndGenerateMetadataAsync(data.EpisodeId, data.EpisodeJsonFilePath, data.OriginalTranscriptFilePath, null, null);
    }

    private async void HandleTranslatedTranscriptReady(TranslatedTranscriptData data)
    {
        Debug.Log($"[YouTubeMetadataGenerator] Received OnTranslatedTranscriptReady: EpisodeId: {data.EpisodeId}, Lang: {data.LanguageCode}, TranscriptPath: {data.TranslatedTranscriptFilePath}, JsonPath: {data.EpisodeJsonFilePath}");
        await ProcessAndGenerateMetadataAsync(data.EpisodeId, data.EpisodeJsonFilePath, data.TranslatedTranscriptFilePath, data.LanguageName, data.LanguageCode);
    }

    private async Task ProcessAndGenerateMetadataAsync(string episodeId, string episodeJsonFullPath, string transcriptPath, string? targetLanguageName, string? targetLanguageCode)
    {
        string langSuffix = string.IsNullOrEmpty(targetLanguageCode) ? "Original" : targetLanguageCode;
        Debug.Log($"[YouTubeMetadataGenerator ({langSuffix})] Processing metadata for EpisodeId: {episodeId}, Lang: {targetLanguageCode ?? "en"}, Transcript: {transcriptPath}");

        if (apiKeysConfig == null)
        {
            Debug.LogError($"[YouTubeMetadataGenerator ({langSuffix})] ShowGeneratorApiKeys config is not assigned. Cannot generate metadata.");
            return;
        }

        if (string.IsNullOrEmpty(episodeJsonFullPath) || string.IsNullOrEmpty(episodeId) || string.IsNullOrEmpty(transcriptPath))
        {
            Debug.LogError($"[YouTubeMetadataGenerator ({langSuffix})] EpisodeId, EpisodeJsonFilePath, or TranscriptPath is missing.");
            return;
        }
        
        FullShowDataFormat? fullShowData = LoadFullShowData(episodeJsonFullPath);
        if (fullShowData == null || fullShowData.config == null || fullShowData.episodes == null || !fullShowData.episodes.Any())
        {
            Debug.LogError($"[YouTubeMetadataGenerator ({langSuffix})] Failed to load or parse show data from: {episodeJsonFullPath}, or data is incomplete.");
            return;
        }

        ShowGenerator.ShowEpisode? targetEpisode = fullShowData.episodes.FirstOrDefault(ep => ep.id == episodeId);
        if (targetEpisode == null)
        {
            if (fullShowData.episodes.Count == 1 && fullShowData.episodes[0].id == episodeId) targetEpisode = fullShowData.episodes[0];
            else
            {
                Debug.LogError($"[YouTubeMetadataGenerator ({langSuffix})] Episode with ID '{episodeId}' not found in {episodeJsonFullPath}. Available: {string.Join(", ", fullShowData.episodes.Select(e => e.id))}");
                return;
            }
        }

        string? aiNewsContent = await FetchAiNewsJsonAsync();
        if (string.IsNullOrEmpty(aiNewsContent))
        {
            Debug.LogWarning($"[YouTubeMetadataGenerator ({langSuffix})] AI News JSON could not be fetched. Proceeding without it.");
            aiNewsContent = "AI News data not available.";
        }

        string transcriptContent = "Transcript not available.";
        try
        {
            if (File.Exists(transcriptPath))
            {
                transcriptContent = File.ReadAllText(transcriptPath);
                Debug.Log($"[YouTubeMetadataGenerator ({langSuffix})] Successfully read transcript from: {transcriptPath}");
            }
            else Debug.LogWarning($"[YouTubeMetadataGenerator ({langSuffix})] Transcript file not found at: {transcriptPath}");
        }
        catch (Exception ex) { Debug.LogError($"[YouTubeMetadataGenerator ({langSuffix})] Error reading transcript file at {transcriptPath}: {ex.Message}"); }

        StringBuilder episodeContextBuilder = new StringBuilder();
        episodeContextBuilder.AppendLine($"Show Name: {fullShowData.config.name}");
        episodeContextBuilder.AppendLine($"Show Description: {fullShowData.config.description}");
        episodeContextBuilder.AppendLine();
        episodeContextBuilder.AppendLine($"Episode ID: {targetEpisode.id}");
        episodeContextBuilder.AppendLine($"Episode Name: {targetEpisode.name}");
        episodeContextBuilder.AppendLine($"Episode Premise: {targetEpisode.premise}");
        episodeContextBuilder.AppendLine($"Episode Summary: {targetEpisode.summary}");
        episodeContextBuilder.AppendLine();
        episodeContextBuilder.AppendLine("Scene Descriptions & Dialogue Highlights:");
        if (targetEpisode.scenes != null)
        {
            foreach (var scene in targetEpisode.scenes)
            {
                episodeContextBuilder.AppendLine($"- Scene ({scene.location}): {scene.description}");
                if (scene.dialogue != null)
                {
                    foreach (var line in scene.dialogue.Take(3)) { episodeContextBuilder.AppendLine($"  {line.actor}: {line.line}"); }
                }
            }
        }
        episodeContextBuilder.AppendLine();
        episodeContextBuilder.AppendLine("Relevant AI News Context:");
        episodeContextBuilder.AppendLine(aiNewsContent);

        LLMMetadataResponse? llmResponse = await GetMetadataFromLLMAsync(episodeContextBuilder.ToString(), transcriptContent, fullShowData.config, targetEpisode, targetLanguageName, langSuffix);
        if (llmResponse == null)
        {
            Debug.LogError($"[YouTubeMetadataGenerator ({langSuffix})] Failed to get metadata from LLM.");
            return;
        }

        string currentDate = DateTime.UtcNow.ToString("yyyy-MM-dd");
        string sanitizedShowName = SanitizeFilename(fullShowData.config.name);
        
        string finalDescription = $"Recorded: {currentDate}\n\n{llmResponse.description}\n\nSources:\n- AI News: {AiNewsJsonUrl}";
        if (transcriptContent != "Transcript not available." && !string.IsNullOrEmpty(transcriptContent))
        {
            finalDescription += $"\n\n--- Transcript ---\n{transcriptContent}";
        }

        // Determine latest video file
        string episodeRecordingsPath = Path.Combine(Application.dataPath, "Resources", "Episodes", episodeId, "recordings");
        string latestVideoRelativePath = $"Resources/Episodes/{episodeId}/recordings/default_video.mp4"; // Fallback
        string latestVideoAbsolutePath = string.Empty;

        if (Directory.Exists(episodeRecordingsPath))
        {
            var recordingDirectory = new DirectoryInfo(episodeRecordingsPath);
            FileInfo latestRecording = recordingDirectory.GetFiles("*.mp4")
                                        .OrderByDescending(f => f.LastWriteTimeUtc)
                                        .FirstOrDefault();
            if (latestRecording != null)
            {
                latestVideoRelativePath = Path.Combine("Resources", "Episodes", episodeId, "recordings", latestRecording.Name).Replace("\\", "/");
                latestVideoAbsolutePath = latestRecording.FullName;
                Debug.Log($"[{langSuffix}] Found latest video: {latestVideoRelativePath}");
            }
            else
            {
                Debug.LogWarning($"[{langSuffix}] No .mp4 recordings found in {episodeRecordingsPath}. Using fallback video path for metadata.");
            }
        }
        else
        {
            Debug.LogWarning($"[{langSuffix}] Recordings directory not found: {episodeRecordingsPath}. Using fallback video path for metadata.");
        }

        // Construct thumbnail path (relative to Assets/Resources/Episodes/{episodeId}/)
        // The original thumbnail_file was just a relative name pattern. We need to make it specific to the episode's resource structure.
        string thumbnailBaseName = $"{sanitizedShowName}_{episodeId}{(string.IsNullOrEmpty(targetLanguageCode) ? "" : "_" + targetLanguageCode)}.jpg";
        // Assuming thumbnails are stored like: Assets/Resources/Episodes/{episodeId}/media/thumbnails/thumbnail.jpg
        string thumbnailRelativePath = Path.Combine("Resources", "Episodes", episodeId, "media", "thumbnails", thumbnailBaseName).Replace("\\", "/");
        string thumbnailAbsolutePath = Path.Combine(Application.dataPath, "Resources", "Episodes", episodeId, "media", "thumbnails", thumbnailBaseName);


        EpisodeMetadata metadata = new EpisodeMetadata
        {
            video_file = latestVideoRelativePath, 
            title = llmResponse.title,
            description = finalDescription,
            tags = llmResponse.tags,
            category_id = defaultCategoryId,
            privacy_status = defaultPrivacyStatus.ToString().ToLowerInvariant(),
            thumbnail_file = thumbnailRelativePath,
            duration = "00:00:00", 
            generated_at = DateTime.UtcNow.ToString("o") 
        };

        EpisodeMetadataContainer container = new EpisodeMetadataContainer { episode_metadata = metadata };
        string metadataFilePath = SaveMetadataToFile(container, fullShowData.config.id, targetEpisode.id, sanitizedShowName, targetLanguageCode, langSuffix);

        if (string.IsNullOrEmpty(metadataFilePath))
        {
            Debug.LogError($"[{langSuffix}] Metadata file path was not returned after saving. Cannot proceed with upload logic for this language.", this);
            return;
        }

        // Check if this language version should be uploaded
        if (enableAutomaticUpload && ShouldUploadThisLanguage(langSuffix))
        {
            Debug.Log($"[{langSuffix}] Automatic upload is ENABLED and language preference MATCHES ('{uploadLanguagePreference}'). Attempting to upload...");
            string[] tagsArray = llmResponse.tags?.Split(',').Select(t => t.Trim()).ToArray() ?? Array.Empty<string>();

            // Convert privacy status string from metadata to enum for the uploader method
            YoutubeUploader.PrivacyStatus privacyStatusEnum = defaultPrivacyStatus;
            if (!string.IsNullOrEmpty(container.episode_metadata?.privacy_status))
            {
                try
                {
                    privacyStatusEnum = (YoutubeUploader.PrivacyStatus)System.Enum.Parse(typeof(YoutubeUploader.PrivacyStatus), container.episode_metadata.privacy_status, true);
                }
                catch (System.ArgumentException)
                {
                    Debug.LogWarning($"[{langSuffix}] Could not parse privacy status '{container.episode_metadata.privacy_status}'. Using default: {privacyStatusEnum}.");
                }
            }

            // Call the uploader
            if (youtubeUploader != null)
            {
                Debug.Log($"[{langSuffix}] Preparing to upload to YouTube. Title: {llmResponse.title}, Privacy: {privacyStatusEnum}, Video Path: {latestVideoAbsolutePath}");
                
                // Corrected method call
                string? videoId = await youtubeUploader.UploadVideoWithDetails(
                    latestVideoAbsolutePath,
                    llmResponse.title ?? "Untitled Video",
                    finalDescription,
                    tagsArray,
                    container.episode_metadata?.category_id ?? defaultCategoryId,
                    privacyStatusEnum,
                    thumbnailAbsolutePath
                );

                if (!string.IsNullOrEmpty(videoId))
                {
                    Debug.Log($"[{langSuffix}] Successfully uploaded video. Video ID: {videoId}. Proceeding to playlist assignment.", this);
                    await HandlePlaylistAssignmentsAsync(videoId, tagsArray, targetLanguageCode, langSuffix);
                }
                else
                {
                    Debug.LogError($"[{langSuffix}] YouTube upload failed. Video ID is null or empty.", this);
                }
            }
            else
            {
                Debug.LogWarning($"[{langSuffix}] YoutubeUploader component is not assigned. Skipping automatic upload.", this);
            }
        }
        else if (enableAutomaticUpload)
        {
            Debug.Log($"[{langSuffix}] Skipping upload for this language based on Upload Language Preference ('{uploadLanguagePreference}').");
        }
    }

    private FullShowDataFormat? LoadFullShowData(string jsonFilePath)
    {
        try
        {
            if (!File.Exists(jsonFilePath))
            {
                Debug.LogError($"[YouTubeMetadataGenerator] JSON file not found at path: {jsonFilePath}");
                return null;
            }
            string jsonContent = File.ReadAllText(jsonFilePath);
            return JsonConvert.DeserializeObject<FullShowDataFormat>(jsonContent);
        }
        catch (Exception ex)
        {
            Debug.LogError($"[YouTubeMetadataGenerator] Error parsing JSON file '{jsonFilePath}': {ex.Message}");
            return null;
        }
    }

    private async Task<string?> FetchAiNewsJsonAsync()
    {
        using (UnityWebRequest webRequest = UnityWebRequest.Get(AiNewsJsonUrl))
        {
            var operation = webRequest.SendWebRequest();
            while (!operation.isDone) { await Task.Yield(); }
            if (webRequest.result == UnityWebRequest.Result.Success)
            {
                Debug.Log("[YouTubeMetadataGenerator] Successfully fetched AI News JSON.");
                return webRequest.downloadHandler.text;
            }
            else
            {
                Debug.LogError($"[YouTubeMetadataGenerator] Error fetching AI News JSON: {webRequest.error}");
                return null;
            }
        }
    }
    
    private string BuildLLMPrompt(string episodeContextForLLM, string transcriptContent, ShowGenerator.ShowConfig showConfig, ShowGenerator.ShowEpisode episode, string? targetLanguageName, string langSuffixForDebug)
    {
        StringBuilder promptBuilder = new StringBuilder();
        promptBuilder.AppendLine("You are an expert YouTube metadata generator.");
        
        if (!string.IsNullOrEmpty(targetLanguageName))
        {
            promptBuilder.AppendLine($"Generate a concise and engaging YouTube title, a detailed YouTube description SUMMARY, and relevant YouTube tags, ALL IN {targetLanguageName.ToUpper()}.");
        }
        else
        {
            promptBuilder.AppendLine("Given the show information, episode content, relevant news, and the full episode transcript, generate a concise and engaging YouTube title, a detailed YouTube description SUMMARY (the full transcript will be appended by the system later), and relevant YouTube tags.");
        }
        
        promptBuilder.AppendLine("Follow the formatting instructions carefully.");
        promptBuilder.AppendLine();
        promptBuilder.AppendLine("## Show Information (for context, output should be in target language if specified):");
        promptBuilder.AppendLine($"- Name: {showConfig.name}");
        promptBuilder.AppendLine($"- Description: {showConfig.description}");
        promptBuilder.AppendLine();
        promptBuilder.AppendLine("## Episode Information (for context, output should be in target language if specified):");
        promptBuilder.AppendLine($"- ID: {episode.id}");
        promptBuilder.AppendLine($"- Title (if available): {episode.name}");
        promptBuilder.AppendLine($"- Premise: {episode.premise}");
        promptBuilder.AppendLine($"- Summary: {episode.summary}");
        promptBuilder.AppendLine();
        promptBuilder.AppendLine("## Episode Content (Highlights & Scene Descriptions) & AI News Context (output should be in target language if specified):");
        promptBuilder.AppendLine(episodeContextForLLM); 
        promptBuilder.AppendLine();
        promptBuilder.AppendLine("## Full Episode Transcript (this is the primary content to summarize IN THE TARGET LANGUAGE if specified):");
        promptBuilder.AppendLine("```transcript");
        promptBuilder.AppendLine(transcriptContent);
        promptBuilder.AppendLine("```");
        promptBuilder.AppendLine();
        promptBuilder.AppendLine("## Instructions for Output:");
        string langInstruction = string.IsNullOrEmpty(targetLanguageName) ? "English" : targetLanguageName;
        promptBuilder.AppendLine($"1.  **YouTube Title (in {langInstruction.ToUpper()}):** Generate a compelling title (max 100 characters). Consider the episode type. For daily episodes, include the current date if appropriate. Example format: \"[Show Name]: [Main Topic 1] & [Main Topic 2] | [Date if daily]\"");
        promptBuilder.AppendLine($"2.  **YouTube Description SUMMARY (in {langInstruction.ToUpper()}):** Generate a detailed description SUMMARY (approx 3-5 sentences). This summary should briefly overview the episode's main themes and highlights, drawing from the episode content and transcript. This summary will be placed BEFORE the full transcript and source links in the final YouTube description. Do not add \"Recorded: ...\", \"Sources: ...\", or the full transcript yourself. Just provide the summary text IN {langInstruction.ToUpper()}.");
        promptBuilder.AppendLine($"3.  **YouTube Tags (in {langInstruction.ToUpper()}, or mix of {langInstruction} and English if appropriate for discoverability):** Generate a comma-separated list of relevant tags (max 500 characters total).");
        promptBuilder.AppendLine();
        promptBuilder.AppendLine($"Please respond ONLY with a JSON object with three keys: \"title\", \"description\" (this should be the summary IN {langInstruction.ToUpper()}), and \"tags\". For example (if {langInstruction} is English):");
        promptBuilder.AppendLine("```json");
        promptBuilder.AppendLine("{");
        promptBuilder.AppendLine("  \"title\": \"AI Breakthroughs & Market Shifts | AI News Daily\",");
        promptBuilder.AppendLine("  \"description\": \"This episode unpacks the latest AI model releases and analyzes their impact on the current market. We explore key advancements in natural language processing and discuss predictions for the upcoming quarter.\",");
        promptBuilder.AppendLine("  \"tags\": \"AI, Artificial Intelligence, Machine Learning, Tech News, Market Analysis, NLP\"");
        promptBuilder.AppendLine("}");
        promptBuilder.AppendLine("```");
        if (!string.IsNullOrEmpty(targetLanguageName) && targetLanguageName != "English")
        {
             promptBuilder.AppendLine($"Remember, ALL parts of the JSON response (title, description, tags) MUST BE IN {targetLanguageName.ToUpper()}.");
        }

        return promptBuilder.ToString();
    }

    private async Task<LLMMetadataResponse?> GetMetadataFromLLMAsync(string episodeContextForLLM, string transcriptContent, ShowGenerator.ShowConfig showConfig, ShowGenerator.ShowEpisode episode, string? targetLanguageName, string langSuffixForDebug)
    {
        if (apiKeysConfig == null)
        {
            Debug.LogError($"[{langSuffixForDebug}] ShowGeneratorApiKeys config is not assigned in GetMetadataFromLLMAsync. Cannot proceed.");
            return null;
        }

        string prompt = BuildLLMPrompt(episodeContextForLLM, transcriptContent, showConfig, episode, targetLanguageName, langSuffixForDebug);

        if (string.IsNullOrEmpty(targetLanguageName))
        {
            lastGeneratedOriginalLLMPrompt = prompt;
        }
        else
        {
            lastGeneratedTranslatedLLMPrompt = prompt;
        }

        string requestUrl;
        object payload; // Use object type for payload as it varies
        var headers = new Dictionary<string, string>
        {
            { "Content-Type", "application/json" }
        };

        if (useWrapperEndpoint)
        {
            if (string.IsNullOrEmpty(apiKeysConfig.claudeWrapperUrl))
            {
                Debug.LogError($"[{langSuffixForDebug}] Claude Wrapper URL is missing in ShowGeneratorApiKeys.");
                return null;
            }
            requestUrl = apiKeysConfig.claudeWrapperUrl;
            payload = new ClaudeApiRequestPayload // Assuming wrapper expects a similar payload or has its own defined structure that matches this for simplicity
            {
                model = !string.IsNullOrEmpty(apiKeysConfig.claudeModelName) ? apiKeysConfig.claudeModelName : "claude-3-opus-20240229",
                messages = new List<ClaudeMessage> { new ClaudeMessage { role = "user", content = prompt } },
                max_tokens = apiKeysConfig.claudeMaxTokens > 0 ? apiKeysConfig.claudeMaxTokens : 2048,
                system = "You are a helpful assistant that generates YouTube video metadata based on episode details and transcripts. Respond ONLY with a JSON object containing 'title', 'description', and 'tags' (comma-separated string). Do not include any other text, context, or markdown formatting like ```json ... ```. Only the raw JSON. For tags, provide a diverse list of relevant keywords."
            };
        }
        else // Direct Anthropic API call
        {
            if (string.IsNullOrEmpty(apiKeysConfig.anthropicApiKey))
            {
                Debug.LogError($"[{langSuffixForDebug}] Anthropic API Key is missing for direct API call.");
                return null;
            }
            requestUrl = DirectClaudeApiUrl;
            headers.Add("x-api-key", apiKeysConfig.anthropicApiKey);
            headers.Add("anthropic-version", ClaudeApiVersion);
            payload = new ClaudeApiRequestPayload
            {
                model = !string.IsNullOrEmpty(apiKeysConfig.claudeModelName) ? apiKeysConfig.claudeModelName : "claude-3-opus-20240229",
                messages = new List<ClaudeMessage> { new ClaudeMessage { role = "user", content = prompt } },
                max_tokens = apiKeysConfig.claudeMaxTokens > 0 ? apiKeysConfig.claudeMaxTokens : 2048,
                system = "You are a helpful assistant that generates YouTube video metadata based on episode details and transcripts. Respond ONLY with a JSON object containing 'title', 'description', and 'tags' (comma-separated string). Do not include any other text, context, or markdown formatting like ```json ... ```. Only the raw JSON. For tags, provide a diverse list of relevant keywords."
            };
        }

        try
        {
            // Call the generic method with the expected response type. The ApiCaller will handle serialization and deserialization.
            ClaudeApiResponse? apiResponse = await ApiCaller.PostJsonAsync<ClaudeApiResponse?>(requestUrl, payload, headers);

            if (apiResponse?.content != null && apiResponse.content.Any() && !string.IsNullOrEmpty(apiResponse.content[0].text))
            {
                // The JSON we want is nested inside the 'text' field of the first content item.
                string nestedJson = apiResponse.content[0].text;
                LLMMetadataResponse? llmResponse = JsonConvert.DeserializeObject<LLMMetadataResponse>(nestedJson);

                if (llmResponse == null)
                {
                    Debug.LogError($"[{langSuffixForDebug}] Failed to deserialize the nested JSON from the LLM response. Nested JSON was: {nestedJson}");
                    return null;
                }
                
                if (string.IsNullOrWhiteSpace(llmResponse.title) || string.IsNullOrWhiteSpace(llmResponse.description) || string.IsNullOrWhiteSpace(llmResponse.tags))
                {
                    Debug.LogWarning($"[{langSuffixForDebug}] LLM response was parsed, but one or more fields are empty. Title: '{llmResponse.title}', Desc: '{llmResponse.description}', Tags: '{llmResponse.tags}'.");
                }
                
                return llmResponse;
            }
            else
            {
                // This case handles both a null apiResponse and a response that doesn't match the expected structure.
                string responseJsonForError = apiResponse != null ? JsonConvert.SerializeObject(apiResponse) : "null";
                Debug.LogError($"[{langSuffixForDebug}] LLM API response was null or not in the expected format (missing content). Response: {responseJsonForError}");
                return null;
            }
        }
        catch (Exception ex)
        {
            Debug.LogError($"[{langSuffixForDebug}] An exception occurred during the LLM API call: {ex.Message}\n{ex.StackTrace}");
            return null;
        }
    }
    
    private string? SaveMetadataToFile(EpisodeMetadataContainer container, string showId, string episodeId, string sanitizedShowName, string? languageCode, string langSuffixForDebug)
    {
        try
        {
            string episodeResourcesDirectory = Path.Combine("Resources", "Episodes", episodeId); // Relative path for Assets
            string metadataDirectoryRelative = Path.Combine(episodeResourcesDirectory, "metadata");
            string metadataDirectoryAbsolute = Path.Combine(Application.dataPath, metadataDirectoryRelative);


            if (!Directory.Exists(metadataDirectoryAbsolute))
            {
                Directory.CreateDirectory(metadataDirectoryAbsolute);
                Debug.Log($"[YouTubeMetadataGenerator ({langSuffixForDebug})] Created directory: {metadataDirectoryAbsolute}");
            }

            string langFileSuffix = string.IsNullOrEmpty(languageCode) ? "" : $"_{languageCode}";
            // Filename should ideally not rely on sanitizedShowName if episodeId is unique and primary key
            // Using a consistent pattern: {episodeId}_metadata{langFileSuffix}.json or {showId}_{episodeId}_metadata{langFileSuffix}.json
            string filename = $"{showId}_{episodeId}_youtube_metadata{langFileSuffix}.json"; // Clarified filename
            string filePathAbsolute = Path.Combine(metadataDirectoryAbsolute, filename);

            string jsonOutput = JsonConvert.SerializeObject(container, Formatting.Indented);
            File.WriteAllText(filePathAbsolute, jsonOutput);

            Debug.Log($"[YouTubeMetadataGenerator ({langSuffixForDebug})] Successfully saved metadata to: {filePathAbsolute}");

            #if UNITY_EDITOR
            // Construct path relative to "Assets/" for AssetDatabase
            string filePathForAssetDB = Path.Combine("Assets", metadataDirectoryRelative, filename);
            UnityEditor.AssetDatabase.ImportAsset(filePathForAssetDB.Replace("\\", "/"));
            // UnityEditor.AssetDatabase.Refresh(); // Refresh can be called once after all operations if many files change
            #endif
            return filePathAbsolute; // Return the full path of the saved metadata file
        }
        catch (Exception ex)
        {
            Debug.LogError($"[YouTubeMetadataGenerator ({langSuffixForDebug})] Error saving metadata to file '{showId}_{episodeId}_youtube_metadata{languageCode}.json': {ex.Message}");
            return null; // Indicate failure
        }
    }

    private bool ShouldUploadThisLanguage(string currentProcessingLanguageSuffix)
    {
        if (string.IsNullOrEmpty(uploadLanguagePreference) || uploadLanguagePreference.Equals("None", StringComparison.OrdinalIgnoreCase))
        {
            return false; // No upload for any language based on this preference
        }

        if (uploadLanguagePreference.Equals("Original", StringComparison.OrdinalIgnoreCase))
        {
            return currentProcessingLanguageSuffix.Equals("Original", StringComparison.OrdinalIgnoreCase);
        }

        // If preference is a full language name (e.g., "Chinese (Simplified)"), we need its code to compare with currentProcessingLanguageSuffix (e.g., "ch")
        if (transcriptGeneratorReference == null)
        {
            Debug.LogError($"[YouTubeMetadataGenerator ({currentProcessingLanguageSuffix})] TranscriptGeneratorReference is not set. Cannot determine language code for preference: {uploadLanguagePreference}. Upload will be skipped for this language.");
            return false;
        }

        // Get the language code for the stored preference (which should be a full name like "Chinese (Simplified)")
        string preferenceCode = transcriptGeneratorReference.GetLanguageCode(uploadLanguagePreference);

        if (string.IsNullOrEmpty(preferenceCode))
        {
            Debug.LogWarning($"[YouTubeMetadataGenerator ({currentProcessingLanguageSuffix})] Could not get a valid language code for preference '{uploadLanguagePreference}'. Upload will be skipped if this was the target.");
            return false;
        }

        // Compare the code of the preference with the current processing language's suffix code
        return preferenceCode.Equals(currentProcessingLanguageSuffix, StringComparison.OrdinalIgnoreCase);
    }

    private async Task HandlePlaylistAssignmentsAsync(string videoId, string[] videoTags, string? languageCode, string langSuffixForLog)
    {
        if (youtubeUploader == null || string.IsNullOrEmpty(videoId))
        {
            Debug.LogError($"[{langSuffixForLog}] YoutubeUploader not assigned or videoId is missing. Cannot assign to playlists.");
            return;
        }

        Debug.Log($"[{langSuffixForLog}] Starting playlist assignment for Video ID: {videoId}...");

        // Simplified Playlist Definitions (based on user provided structure)
        var playlistRules = new List<PlaylistRule>
        {
            // --- English/Original Playlists ---
            new PlaylistRule { 
                TargetLanguageCode = null, // Represents "Original"
                Title = "AI News Daily Episodes", 
                Description = "Daily AI news covering ElizaOS updates, market analysis, and ecosystem developments.", 
                Privacy = "public", 
                RequiredTags = new List<string> { "daily", "main_show" },
                ApiLanguageCode = "en"
            },
            new PlaylistRule { 
                TargetLanguageCode = null, 
                Title = "Market Analysis with Spartan & Pepo", 
                Description = "Daily market updates and crypto analysis segments.", 
                Privacy = "public", 
                RequiredTags = new List<string> { "market", "stonks" },
                ApiLanguageCode = "en"
            },
            new PlaylistRule { 
                TargetLanguageCode = null, 
                Title = "Ecosystem Interviews", 
                Description = "Interviews with partners, DAOs, and community members.", 
                Privacy = "public", 
                RequiredTags = new List<string> { "interview", "splitscreen" },
                ApiLanguageCode = "en"
            },
            // --- Korean Playlists ---
            new PlaylistRule { 
                TargetLanguageCode = "ko", 
                Title = "AI 뉴스 한국어", // AI News Korean
                Description = "Korean language episodes covering AI and blockchain news.", 
                Privacy = "public", 
                RequiredTags = new List<string> { "daily", "main_show", "korean" }, // Adjust tags as needed for translated content
                ApiLanguageCode = "ko"
            },
            new PlaylistRule { 
                TargetLanguageCode = "ko", 
                Title = "시장 분석 한국어", // Market Analysis Korean
                Description = "Korean market content.", 
                Privacy = "public", 
                RequiredTags = new List<string> { "market", "stonks", "korean" },
                ApiLanguageCode = "ko"
            },
             new PlaylistRule { 
                TargetLanguageCode = "ko", 
                Title = "인터뷰 한국어", // Interviews Korean
                Description = "Korean interview content.", 
                Privacy = "public", 
                RequiredTags = new List<string> { "interview", "splitscreen", "korean" },
                ApiLanguageCode = "ko"
            },
            // --- Chinese Playlists ---
            new PlaylistRule { 
                TargetLanguageCode = "ch", // Assuming "ch" is the code used from YouTubeTranscriptGenerator
                Title = "AI新闻中文版", // AI News Chinese
                Description = "Chinese language episodes covering AI and blockchain news.", 
                Privacy = "public", 
                RequiredTags = new List<string> { "daily", "main_show", "chinese" }, // Adjust tags
                ApiLanguageCode = "zh-CN" // YouTube API uses BCP-47 codes for playlist default language
            },
            new PlaylistRule { 
                TargetLanguageCode = "ch", 
                Title = "市场分析中文版", // Market Analysis Chinese
                Description = "Chinese market content.", 
                Privacy = "public", 
                RequiredTags = new List<string> { "market", "stonks", "chinese" },
                ApiLanguageCode = "zh-CN"
            },
            new PlaylistRule { 
                TargetLanguageCode = "ch", 
                Title = "访谈中文版", // Interviews Chinese
                Description = "Chinese interview content.", 
                Privacy = "public", 
                RequiredTags = new List<string> { "interview", "splitscreen", "chinese" },
                ApiLanguageCode = "zh-CN"
            }
        };

        string currentVideoLanguageNormalized = string.IsNullOrEmpty(languageCode) ? null : languageCode; // Null for "Original"

        foreach (var rule in playlistRules)
        {
            bool languageMatch = (rule.TargetLanguageCode == null && currentVideoLanguageNormalized == null) || 
                                 (rule.TargetLanguageCode != null && rule.TargetLanguageCode.Equals(currentVideoLanguageNormalized, StringComparison.OrdinalIgnoreCase));

            if (languageMatch)
            {
                bool tagsMatch = rule.RequiredTags.Any(reqTag => videoTags.Contains(reqTag, StringComparer.OrdinalIgnoreCase));
                if (tagsMatch)
                {
                    Debug.Log($"[{langSuffixForLog}] Video matches criteria for playlist '{rule.Title}'. Attempting to get/create and add.");
                    string playlistId = await youtubeUploader.GetOrCreatePlaylistAsync(rule.Title, rule.Description, rule.Privacy, rule.ApiLanguageCode);
                    if (!string.IsNullOrEmpty(playlistId))
                    {
                        await youtubeUploader.AddVideoToPlaylistAsync(videoId, playlistId);
                    }
                    else
                    {
                        Debug.LogError($"[{langSuffixForLog}] Failed to get or create playlist '{rule.Title}'. Video not added.");
                    }
                }
            }
        }
        Debug.Log($"[{langSuffixForLog}] Finished playlist assignment attempts for Video ID: {videoId}.");
    }

    // Helper class for defining playlist rules
    private class PlaylistRule
    {
        public string? TargetLanguageCode { get; set; } // null for Original/English
        public string? Title { get; set; }
        public string? Description { get; set; }
        public string? Privacy { get; set; }
        public List<string>? RequiredTags { get; set; }
        public string? ApiLanguageCode { get; set; } // For YouTube API's defaultLanguage (e.g., "en", "ko", "zh-CN")
    }

    private string SanitizeFilename(string? name)
    {
        if (string.IsNullOrEmpty(name)) return "untitled";
        return Regex.Replace(name, "[^a-zA-Z0-9_.-]+", "_", RegexOptions.Compiled);
    }
} 